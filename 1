from flask import Flask, render_template, request, redirect, url_for, send_from_directory
import os
import cv2
import pickle
import face_recognition
import pandas as pd
from datetime import datetime

app = Flask(__name__)

# Ensure necessary directories exist
if not os.path.exists('known_faces'):
    os.makedirs('known_faces')
if not os.path.exists('detected_faces'):
    os.makedirs('detected_faces')

# Load known face encodings and details
def load_known_faces():
    if os.path.exists('encodings.pickle'):
        try:
            with open('encodings.pickle', 'rb') as f:
                return pickle.load(f)
        except (EOFError, pickle.PickleError) as e:
            print(f"Error loading encodings: {e}")
            return [], []
    return [], []

known_faces, known_names = load_known_faces()

@app.route('/')
def index():
    # Load attendance data
    if os.path.exists('attendance.csv'):
        try:
            df = pd.read_csv('attendance.csv')
        except pd.errors.EmptyDataError:
            df = pd.DataFrame(columns=['Name', 'Time'])
    else:
        df = pd.DataFrame(columns=['Name', 'Time'])
    
    return render_template('index.html', tables=[df.to_html(classes='data', escape=False)], titles=df.columns.values)

@app.route('/enroll', methods=['GET', 'POST'])
def enroll():
    if request.method == 'POST':
        name = request.form['name']
        admission_number = request.form['admission_number']
        mobile_number = request.form['mobile_number']
        
        # Trigger face registration
        if name:
            register_face(name, admission_number, mobile_number)
        
        return redirect(url_for('index'))
    
    return render_template('enroll.html')

def register_face(name, admission_number, mobile_number):
    # Initialize webcam
    video_capture = cv2.VideoCapture(0)
    print(f"Please look at the camera for face registration...")

    # Capture a single frame
    ret, frame = video_capture.read()
    if ret:
        face_image_path = f'known_faces/{name}.jpg'
        cv2.imwrite(face_image_path, frame)

        # Encode the new face
        rgb_frame = frame[:, :, ::-1]
        face_encoding = face_recognition.face_encodings(rgb_frame)
        if face_encoding:
            known_faces.append(face_encoding[0])
            known_names.append(name)
            
            # Save the updated encodings
            with open('encodings.pickle', 'wb') as f:
                pickle.dump((known_faces, known_names), f)

            # Save additional information
            with open('details.csv', 'a') as f:
                f.write(f'{name},{admission_number},{mobile_number}\n')
        else:
            print("No face detected.")
    else:
        print("Failed to capture image.")
    
    video_capture.release()

@app.route('/attendance')
def attendance():
    # Load attendance data
    if os.path.exists('attendance.csv'):
        try:
            df = pd.read_csv('attendance.csv')
        except pd.errors.EmptyDataError:
            df = pd.DataFrame(columns=['Name', 'Time'])
    else:
        df = pd.DataFrame(columns=['Name', 'Time'])

    # Load face details
    if os.path.exists('details.csv'):
        try:
            details_df = pd.read_csv('details.csv', names=['Name', 'Admission Number', 'Mobile Number'])
        except pd.errors.EmptyDataError:
            details_df = pd.DataFrame(columns=['Name', 'Admission Number', 'Mobile Number'])
    else:
        details_df = pd.DataFrame(columns=['Name', 'Admission Number', 'Mobile Number'])

    # Merge attendance data with details
    df = df.merge(details_df, on='Name', how='left')
    df.reset_index(drop=True, inplace=True)
    df.index += 1  # Start serial numbers from 1

    # Generate file paths for detected images
    df['Detected Image'] = df['Name'].apply(lambda x: f'/detected_faces/{x}.jpg' if os.path.exists(f'detected_faces/{x}.jpg') else '')

    return render_template('attendance.html', tables=[df.to_html(classes='data', escape=False)], titles=df.columns.values)

@app.route('/detected_faces/<filename>')
def get_detected_image(filename):
    return send_from_directory('detected_faces', filename)

def detect_faces():
    video_capture = cv2.VideoCapture(0)
    while True:
        ret, frame = video_capture.read()
        if not ret:
            continue

        rgb_frame = frame[:, :, ::-1]
        face_locations = face_recognition.face_locations(rgb_frame)
        face_encodings = face_recognition.face_encodings(rgb_frame, face_locations)

        for (top, right, bottom, left), face_encoding in zip(face_locations, face_encodings):
            matches = face_recognition.compare_faces(known_faces, face_encoding)
            name = "Unknown"
            if True in matches:
                first_match_index = matches.index(True)
                name = known_names[first_match_index]

            # Draw bounding box and label
            color = (0, 255, 0) if name != "Unknown" else (0, 0, 255)
            label = name if name != "Unknown" else "Unknown User"
            cv2.rectangle(frame, (left, top), (right, bottom), color, 2)
            font = cv2.FONT_HERSHEY_DUPLEX
            cv2.putText(frame, label, (left + 6, bottom - 6), font, 0.5, color, 1)

            # Save detected image if the face is recognized
            if name != "Unknown":
                detected_image_path = f'detected_faces/{name}.jpg'
                cv2.imwrite(detected_image_path, frame)
                
                # Update attendance file
                timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                if not os.path.exists('attendance.csv'):
                    with open('attendance.csv', 'w') as f:
                        f.write('Name,Time\n')
                
                df = pd.read_csv('attendance.csv')
                if name not in df['Name'].values:
                    new_row = pd.DataFrame([[name, timestamp]], columns=['Name', 'Time'])
                    df = pd.concat([df, new_row], ignore_index=True)
                    df.to_csv('attendance.csv', index=False)

        cv2.imshow('Face Detection', frame)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    video_capture.release()
    cv2.destroyAllWindows()

if __name__ == "__main__":
    import threading
    threading.Thread(target=detect_faces, daemon=True).start()
    app.run(host='0.0.0.0', port=5000, debug=True)
